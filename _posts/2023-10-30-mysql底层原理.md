---
title: 'Msql底层原理'
layout: post
tags:
  - mysql
category: 数据库
---
关系型数据库 mysql。

<!--more-->

# 一、运行逻辑
## 接收SQL
![20231030170238](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231030170238.png)

## 处理数据(存储引擎：InnoDB)
![20231030181732](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231030181732.png)
一切操作都在buffer pool内存中进行，buffer pool根据一定规则去与磁盘进行操作交换数据，操作最小单位为页（16KB，操作系统操作最小单位为4KB，因此需要另一种策略保证页不丢失）

## 执行流程
![20231031102344](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031102344.png)

## HandlerAPI

### Undo Log
解决问题：在每个事务中，通过记录每次操作下逻辑相反的语句和链表记录事务版本，从而实现事务的commit和回滚，并且结合mvcc机制解决读未提交、不可重复读（隔离级别：读已提交、可重复读）的隔离级别
逻辑顺序：
1、在每次事务的操作时，生成一个事务页，便将其链到事务版本管理中
2、生成一条相反逻辑的语句，写入事务页
3、事务提交时，先更新bin，在commit标记上redo log，最后将事务标记为已提交
4、事务回滚时，执行undo log中的语句实现数据回溯，断开该事务的链表前后键

### Redo Log
解决问题：保证mysql操作内存buffer Pool的数据在服务挂掉之后重启能恢复数据（崩溃恢复）
逻辑顺序：
1、在buffer pool操作之后，立即将操作语句写入redo log buffer
2、另启动一个程序根据刷盘策略对redo log buffer的内容进行硬盘存储（默认为每次写入都刷盘）
3、服务重启时，先从redo log进行恢复

#### redo log刷盘策略
设置为 0 ：表示每次事务提交时不进行刷盘操作。 （系统默认master thread每隔1秒进行一次重做日志的同步）
设置为 1 ：表示每次事务提交时都将进行同步，刷盘操作 （默认值）
设置为 2 ：表示每次事务提交时都只把 redo log buffer 内容写入 Page Cache ，不进行同步。 由OS自己决定什么时候同步到磁盘文件。

# 二、底层逻辑

## 物理结构
### 页

### 区

### 组

## 逻辑结构
## 段

## B+树

## 索引

### 聚簇索引（一级索引）

### 非聚簇索引（二级索引）

### 回表

### 索引失效

### 索引优化


# 三、存储引擎
## innodb和myisam的区别

# 四、事务机制
## ACID原则

## 读写问题

### 脏读

### 读为提交

### 不可重复度

### 幻读

## 隔离级别

### 未提交读

### 读已提交

### 可重复读（默认）

### 串行化

## MVCC原理
### 锁

### undo log

### read view

# 五、分库

# 六、容灾