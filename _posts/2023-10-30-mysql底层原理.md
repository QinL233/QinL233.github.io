---
title: 'Msql底层原理'
layout: post
tags:
  - mysql
category: 数据库
---
关系型数据库 mysql。

<!--more-->

# 一、运行逻辑
## (a)、从接收的角度
![20231030170238](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231030170238.png)
![20231031102344](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031102344.png)

## (b)、从存储引擎（InnoDB）的角度（提供handlerAPI）
![20231030181732](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231030181732.png)
![20231031103150](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031103150.png)
一切操作都在buffer pool内存中进行，buffer pool根据一定规则去与磁盘进行操作交换数据，操作最小单位为页（16KB，操作系统操作最小单位为4KB，因此需要另一种策略保证页不丢失）

## (c)、存储引擎的区别
1、MyISAM：如果应用是以查询和插入操作为主，只有极少更新和删除操作，并且对事务的完整性没有要求，没有并发写操作

2、InnoDB：用于事务处理应用程序，支持外键。对事务的完整性有较高要求，除了查询和插入操作外，还有很多更新和删除操作。有效的降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚。实现了四个标准的隔离级别，默认级别是可重复读。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读

3、MEMORY：数据存在内存中，默认使用HASH索引，访问速度快，服务关闭数据就会丢失。通常用于更新不太频繁的小表，可以快速得到访问结果。缺陷是对表的大小有限制，表太大无法缓存在内存中，其次要确保表的数据可以恢复

4、MERGE：是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身没有数据，查询、更新、删除操作实际上是对内部的MyISAM表进行的。DROP操作只是删除MERGE表的定义，对内部的表没有任何影响。优点在于可以突破对单个MyISAM表大小的限制，并且通过将不同的表分布在多个磁盘上，可以有效地改善MERGE表的访问效率

# 二、底层逻辑
## (a)、LOG文件
### 1、Undo Log
![20231031103913](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031103913.png)
![20231031104651](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031104651.png)
解决问题：

1、原子性：在每个事务中，通过记录每次操作下逻辑相反的语句和链表记录事务版本，从而实现事务的commit和回滚

2、隔离性（隔离级别：读已提交、可重复读）：其版本链条结合mvcc快照读（read view）机制解决读未提交、不可重复读

逻辑顺序：

1、在每次事务的操作时，生成一个事务页，便将其链到事务版本管理中

2、生成一条相反逻辑的语句，写入事务页

3、事务提交时，先更新bin，在commit标记上redo log，最后将事务标记为已提交

4、事务回滚时，执行undo log中的语句实现数据回溯，断开该事务的链表前后键

底层结构：

1、新增：增加insert_rec记录主键即可，通过组件即可完成删除操作以回滚

2、删除：记录del_mark记录事务id、roll_pointer（数据行的事务版本链）、主键

3、更新：不更新某一条数据的主键时只需记录upd_exist的事务id、roll_pointer、主键和更新内容；反之，通过一笔新增Insert_rec和一笔删除del_mark两条undo_log操作

### 2、Redo Log（是在InnoDB中的）
解决问题：

保证mysql操作内存buffer Pool的数据在服务挂掉之后重启能恢复数据（崩溃恢复）

逻辑顺序：

1、在buffer pool操作之后，立即将操作语句写入redo log buffer

2、另启动一个程序根据刷盘策略对redo log buffer的内容进行硬盘存储（默认为每次写入都刷盘）

3、服务重启时，先从redo log进行恢复

redo log刷盘策略：

1、设置为 0 ：表示每次事务提交时不进行刷盘操作。 （系统默认master thread每隔1秒进行一次重做日志的同步）

2、设置为 1 ：表示每次事务提交时都将进行同步，刷盘操作 （默认值）

3、设置为 2 ：表示每次事务提交时都只把 redo log buffer 内容写入 Page Cache ，不进行同步。 由OS自己决定什么时候同步到磁盘文件

## (b)、idb 物理结构
### 页

### 区

### 组

## (c)、idb 逻辑结构
## 段

## B+树

## 索引

### 聚簇索引（一级索引）

### 非聚簇索引（二级索引）

### 回表

### 索引失效

### 索引优化


# 三、存储引擎
## innodb和myisam的区别

# 四、事务机制
## ACID原则

## 读写问题

### 脏读

### 读为提交

### 不可重复度

### 幻读

## 隔离级别

### 未提交读

### 读已提交

### 可重复读（默认）

### 串行化

## MVCC原理
### 锁

### undo log

### read view

# 五、分库

# 六、容灾