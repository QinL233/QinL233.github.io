---
title: 'Msql底层原理'
layout: post
tags:
  - mysql
category: 数据库
---
关系型数据库 mysql。

<!--more-->

# 一、运行逻辑
## (a)、从接收的角度
![20231030170238](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231030170238.png)
![20231031102344](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031102344.png)

## (b)、从存储引擎（InnoDB）的角度（提供handlerAPI）
![20231030181732](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231030181732.png)
![20231031103150](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031103150.png)
一切操作都在buffer pool内存中进行，buffer pool根据一定规则去与磁盘进行操作交换数据，操作最小单位为页（16KB，操作系统操作最小单位为4KB，因此需要另一种策略保证页不丢失）

## (c)、存储引擎的区别
1、MyISAM：如果应用是以查询和插入操作为主，只有极少更新和删除操作，并且对事务的完整性没有要求，没有并发写操作

2、InnoDB：用于事务处理应用程序，支持外键。对事务的完整性有较高要求，除了查询和插入操作外，还有很多更新和删除操作。有效的降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚。实现了四个标准的隔离级别，默认级别是可重复读。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读

3、MEMORY：数据存在内存中，默认使用HASH索引，访问速度快，服务关闭数据就会丢失。通常用于更新不太频繁的小表，可以快速得到访问结果。缺陷是对表的大小有限制，表太大无法缓存在内存中，其次要确保表的数据可以恢复

4、MERGE：是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身没有数据，查询、更新、删除操作实际上是对内部的MyISAM表进行的。DROP操作只是删除MERGE表的定义，对内部的表没有任何影响。优点在于可以突破对单个MyISAM表大小的限制，并且通过将不同的表分布在多个磁盘上，可以有效地改善MERGE表的访问效率

# 二、底层逻辑
## (a)、LOG文件
### 1、Undo Log
![20231031103913](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031103913.png)
![20231031104651](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031104651.png)
![20231031105512](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信图片_20231031105512.png)
#### 解决问题：
1、原子性：在每个事务中，通过记录每次操作下逻辑相反的语句和链表记录事务版本，从而实现事务的commit和回滚

2、隔离性（隔离级别：读已提交、可重复读）：其版本链条结合mvcc快照读（read view）机制解决读未提交、不可重复读

#### 逻辑顺序：
1、在每次事务的操作时，生成一个事务页，便将其链到事务版本管理中

2、生成一条相反逻辑的语句，写入事务页

3、事务提交时，先更新bin，在commit标记上redo log，最后将事务标记为已提交

4、事务回滚时，执行undo log中的语句实现数据回溯，断开该事务的链表前后键

#### 底层结构：
1、新增：增加insert_rec记录主键即可，通过组件即可完成删除操作以回滚

2、删除：记录del_mark记录事务id、roll_pointer（数据行的事务版本链）、主键

3、更新：不更新某一条数据的主键时只需记录upd_exist的事务id、roll_pointer、主键和更新内容；反之，通过一笔新增Insert_rec和一笔删除del_mark两条undo_log操作

### 2、Redo Log（是在InnoDB中的）
![微信截图_20231031111337](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031111337.png)
![微信截图_20231031122756](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031122756.png)
#### 解决问题：
保证mysql操作内存buffer Pool的数据在服务挂掉之后重启能恢复数据（崩溃恢复 / 两阶段提交）

#### 逻辑顺序：
1、在buffer pool操作之后，立即将操作语句写入redo log buffer（此时未提交）

2、另启动一个程序根据刷盘策略对redo log buffer的内容进行硬盘存储（默认为每次写入都刷盘）

3、同时将操作记录在（bin log cache），事务提交后刷盘，并在记录完毕后给redo log打上（已提交）标记

3、服务重启时，先从redo log进行恢复

【注意】也就是说未提交的事务，也有可能被redo log记录，在mysql重启后从redo log读到未提交时将从bin log情况进行判断事务是否完整才会恢复数据

#### redo log刷盘策略：
1、设置为 0 ：表示每次事务提交时不进行刷盘操作。 （系统默认master thread每隔1秒进行一次重做日志的同步）

2、设置为 1 ：表示每次事务提交时都将进行同步，刷盘操作 （默认值）

3、设置为 2 ：表示每次事务提交时都只把 redo log buffer 内容写入 Page Cache ，不进行同步。 由OS自己决定什么时候同步到磁盘文件

### 3、Bin LOG（不在InnoDB等存储引擎中，是mysql独立的日志引擎）
![微信截图_20231031110755](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031110755.png)
![微信截图_20231031111013](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031111013.png)
#### 主要作用
1、数据恢复：MySQL可以通过bin log恢复某一时刻的误操作的数据，是DBA常打交道的日志。

2、数据复制：MySQL的数据备份、集群高可用、读写分离都是基于bin log的重放实现的

#### 与redo的区别
1、redo log是物理日志，记录内容是“在某个数据页上做了什么修改”，属于InnoDB存储引擎层，在事务过程中是不断写入的。

2、bin log 是逻辑日志，记录内容是语句的原始逻辑，属于Server层，只在事务提交时才写入。

## (b)、idb 物理结构
### page - 页（树节点）
![微信截图_20231031130709](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031130709.png)
![微信截图_20231031130835](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031130835.png)
![微信截图_20231031132511](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031132511.png)

1、File Header，表示页的一些通用信息，占固定的38字节。

2、Page Header，表示数据页专有的一些信息，占固定的56个字节。

3、Infimum + Supremum，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节。

4、User Records：真实存储我们插入的记录的部分，大小不固定。

5、Free Space：页中尚未使用的部分，大小不确定。

6、Page Directory：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。

7、File Trailer：用于检验页是否完整的部分，占用固定的8个字节

#### 1、row - 行
![微信截图_20231031130935](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031130935.png)
![微信截图_20231031131114](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031131114.png)

##### 额外信息
1、可变长列表：记录所有可变长字段类型的长度以便于分配空间

2、NULL列表：使用逆排表示null值，例如null列表使用【0100】倒叙表示真实数据【1列，2列，3列，4列】第三列未null

3、记录头信息
![微信截图_20231031142809](https://raw.githubusercontent.com/QinL233/QinL233.github.io/master/images/微信截图_20231031142809.png)

4、溢出页：当行数据超过16KB（页最大值）时，多余的存储放到溢出页中

##### 行类型


#### 2、组（二分查找）

### extent - 区（64个连续的页：1MB (64*16K)）

### segment - 段（256个区：256MB）

## (c)、idb 逻辑结构
## 段

## B+树

## 索引

### 聚簇索引（一级索引）

### 非聚簇索引（二级索引）

### 回表

### 索引失效

### 索引优化


# 三、存储引擎
## innodb和myisam的区别

# 四、事务机制
## ACID原则

## 读写问题

### 脏读

### 读为提交

### 不可重复度

### 幻读

## 隔离级别

### 未提交读

### 读已提交

### 可重复读（默认）

### 串行化

## MVCC原理
### 锁

### undo log

### read view

# 五、分库

# 六、容灾